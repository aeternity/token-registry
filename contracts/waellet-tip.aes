contract WaelletTip =

  record state = 
    { websites: map(string, website)
    , tip_seq_id: int }

  record website = 
    { domain: string
    , challenge: option(string)
    , verified: bool
    , date_expire: int
    , owner: map(address, timeframe)
    , balance: int
    , tips: map(int, tip) }

  record tip = 
    { seq_id: int
    , repaid: bool
    , sender: address
    , date_received: int
    , amount: int
    , note: option(string) }

  record timeframe = 
    { date_from: int
    , date_to: int }

  datatype event = 
      LogTipReceived(indexed address, indexed int, string) 
    | LogWebsiteAdded(indexed address, indexed int, string)
    | LogWebsiteVerified(indexed address, indexed int, string)
    | LogWebsiteChallengeGenerated(indexed address, indexed int, string)
    | LogTipsWithdrawn(indexed address, indexed int, indexed int)

  entrypoint init() : state = { websites = {}, tip_seq_id = 0 }

  stateful entrypoint tip(domain: string, note: option(string)) : unit =
    is_website_present(domain)
    let tip : tip = { seq_id = state.tip_seq_id
                    , repaid = false
                    , sender = Call.caller
                    , date_received = Chain.timestamp
                    , amount = Call.value
                    , note = note }

    put(state{ websites[domain].tips[state.tip_seq_id] = tip })
    put(state{ websites[domain].balance @ b = b + Call.value })
    put(state{ tip_seq_id = state.tip_seq_id + 1 })
    Chain.event(LogTipReceived(Call.caller, Call.value, domain))

  entrypoint balance(domain:string) : option(int) =
    switch(Map.lookup(domain, state.websites))
      None => Some(0)
      Some(x) => Some(state.websites[domain].balance)

  entrypoint status(domain: string) : option(bool) =
    switch(Map.lookup(domain, state.websites))
      None => Some(false)
      Some(x) => Some(state.websites[domain].verified)

  stateful entrypoint claim(domain: string) : string =
    is_domain_expired(domain)
    challenge_generate(domain)

  stateful entrypoint verify(domain: string) : bool =
    challenge_check(domain)

  stateful entrypoint withdraw(domain: string) : unit =
    is_domain_owner(domain)
    is_enough_balance(domain)
    let tips_for_payment_list : list(int) = get_tips_for_payment_list(domain: string)
    let withdraw_amount : int = get_withdraw_amount(tips_for_payment_list, domain: string)
    require(withdraw_amount > 0, "INSUFFICIENT_BALANCE")
    put(state{websites[domain].balance @ b = b - withdraw_amount})
    require(set_tips_repaid(tips_for_payment_list, domain), "ERROR_TIPS_PAYMENT")
    Chain.spend(Call.caller, withdraw_amount)
    Chain.event(LogTipsWithdrawn(Call.caller, Chain.timestamp, withdraw_amount))

  // PRIVATE FUNCTIONS AND MODIFIERS

  function get_tips_for_payment_list(domain: string) : list(int) =
    // return all the tips for certain domain
    filter_owner(filter_unpaid_tips(Map.to_list(state.websites[domain].tips), []), domain)

  function filter_unpaid_tips(tips: list((int * tip)), unpaid_tips_ids: list(int)) : list(int) =
    switch(tips)
      [] => unpaid_tips_ids
      (id, tip) :: l' =>
        switch(tip.repaid)
          false => tip.seq_id :: unpaid_tips_ids
        filter_unpaid_tips(l', unpaid_tips_ids)

  function filter_owner(tips: list(int), domain: string) : list(int) =
    filter_owner'(tips, domain, [])
  
  function filter_owner'(tips: list(int), domain: string, filtered: list(int)) : list(int) =
    switch(tips)
      [] => filtered
      e :: l' =>
        switch(ownership_timeframe_matches(state.websites[domain].tips[e], domain))
          true => e :: filtered
        filter_owner'(l', domain, filtered)
           
  function ownership_timeframe_matches(tip : tip, domain: string) : bool =
    diff(tip, state.websites[domain].owner[Call.caller] : timeframe)

  function get_withdraw_amount(tips_for_payment: list(int), domain: string) : int =
    // filter the tips for the current timeframe ownership
    possible_withdraw_amount(tips_for_payment, domain) 

  function possible_withdraw_amount(tips: list(int), domain: string) : int =
    sum((tip_id) => (state.websites[domain].tips[tip_id].amount), tips)

  function diff(tip : tip, timeframe: timeframe) : bool = tip.date_received >= timeframe.date_from && tip.date_received =< timeframe.date_to

  stateful function set_tips_repaid(tips: list(int), domain: string) : bool =
    // iterate over all the tips in list and set the repaid property to true
    set_tips_repaid'(tips, domain)

  stateful function set_tips_repaid'(tips : list(int), domain: string) : bool =
    switch(tips)
      [] => true
      e :: l' =>
        put(state{ websites[domain].tips[e].repaid = true })
        set_tips_repaid'(l', domain)

  stateful function challenge_generate(domain: string) : string =
    let challenge = Bytes.to_str(String.blake2b(String.concat(Address.to_str(Call.caller), domain)))
    is_website_present(domain)
    put(state{ websites[domain].challenge = Some(challenge) })
    Chain.event(LogWebsiteChallengeGenerated(Call.caller, Chain.timestamp, String.concat(String.concat("waellet-tip-verification","="),challenge)))
    challenge

  stateful function challenge_check(domain: string) : bool =
    // Call oracle and verify challenge
    // let oracle_response = query_oracle_here(domain)
    // if(oracle_response == state.websites[domain].challenge)
    // put(state{ websites[domain].verified = true })
    
    // Testing:
    put(state{ websites[domain].verified = true })
    Chain.event(LogWebsiteVerified(Call.caller, Chain.timestamp, domain))
    true

  function is_domain_owner(domain: string) : unit =
    require(state.websites[domain].owner[Call.caller].date_to != 0
      && state.websites[domain].owner[Call.caller].date_from =< Chain.timestamp
      && state.websites[domain].owner[Call.caller].date_to >= Chain.timestamp
      , "NOT_DOMAIN_OWNER")

  function is_enough_balance(domain: string) : unit =
    require(state.websites[domain].balance > 0, "INSUFFICIENT_BALANCE")

  entrypoint all_domain_expire_dates(domain) : list(int) =
    let domain_expires_list = Map.to_list(state.websites[domain].owner)
    map(tuple_second, domain_expires_list)

  function is_domain_expired(domain: string) : bool =
    switch(Map.member(domain, state.websites))
      false => true
      true => is_domain_expired'(all_domain_expire_dates(domain))

  function is_domain_expired'(domain_expires_list: list(int)) : bool =
    switch(domain_expires_list)
      [] => true
      e :: l' =>
        if(e =< Chain.timestamp)
          false
        else
          is_domain_expired'(l')

  stateful function is_website_present(domain: string) : unit =
    if(!Map.member(domain, state.websites))
      let website : website = { domain = domain
                              , challenge = None
                              , verified = false
                              , date_expire = 0
                              , owner = {}
                              , balance = 0
                              , tips = {} }
      put(state{ websites[domain] = website })
      Chain.event(LogWebsiteAdded(Call.caller, Chain.timestamp, domain))
  
  // general helper functions //

  function length(l : list('a)) : int = length'(l, 0)
  function length'(l : list('a), x : int) : int =
    switch(l)
      [] => x
      _ :: l' => length'(l', x + 1)

  function tuple_second(tuple) =
    switch(tuple)
      (_, e) => e.date_to

  function sum(f : 'a => int, l : list('a)) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))

  function insert_by(f: (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =
    switch(l)
      [] => [x]
      (e :: l') =>
        if(f(x, e))
          e :: insert_by(f, x, l')
        else
          x :: l

  function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

  function is_greater_zero(x : int) : bool = x > 0