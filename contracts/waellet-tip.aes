contract WaelletTip =

  record state = { websites: map(string, website) }

  record website = { domain: string
                   , challenge: hash
                   , verified: bool
                   , date_expire: int
                   , owner: map(address, timeframe)
                   , balance: int
                   , tips: list(tip) }

  record tip = { repaid: bool
               , sender: address
               , date_received: int
               , amount: int
               , note: option(string) }

  record timeframe = { date_from: int
                     , date_to: int }

  datatype event = 
      LogTipReceived(indexed address, indexed int, string) 
    | LogWebsiteVerified(indexed address, indexed int, string)
    | LogTipsWithdrawn(indexed address, indexed int)

  stateful entrypoint init() = { websites = {} }

  stateful entrypoint tip(domain: string, note: option(string)) =
    is_website_present(domain)
    let tip : tip = { repaid = false
                    , sender = Call.caller
                    , date_received = Chain.timestamp
                    , amount = Call.value
                    , note = note }

    put(state{ websites[domain].tips = tip :: state.websites[domain].tips })
    put(state{ websites[domain].balance = Call.value + state.websites[domain].balance })
    Chain.event(LogTipReceived(Call.caller, Call.value, domain))

  entrypoint balance(domain:string) : int =
    state.websites[domain].balance

  stateful entrypoint claim(domain: string) : hash =
    is_domain_expired(domain)
    challenge_generate(domain)

  stateful entrypoint withdraw(domain: string) =
    is_domain_owner(domain)
    is_enough_balance(domain)

    let tips_for_payment_list = get_tips_for_payment_list(domain: string)

    let withdraw_amount = get_withdraw_amount(tips_for_payment_list, domain: string)

    require(withdraw_amount > 0, "You dont have pending balance for withdrawal")
    
    put(state{websites[domain].balance = state.websites[domain].balance - withdraw_amount})
    
    require(set_tips_repaid(tips_for_payment_list), "Something went wrong with the tips")
    
    Chain.spend(Call.caller, withdraw_amount)
    Chain.event(LogTipsWithdrawn(Call.caller, withdraw_amount))

  // PRIVATE FUNCTIONS AND MODIFIERS

  private function get_withdraw_amount(tips_for_payment: list(tip), domain: string) : int =
    // filter the tips for the current timeframe ownership
    let tips : list(tip) = current_ownership_tips(tips_for_payment, state.websites[domain].owner[Call.caller] : timeframe)
    // filter the repaid tips
    let unpaid_tips : list(tip) = filter_unpaid_tips(tips)
    // return the possible withdraw amount
    possible_withdraw_amount(unpaid_tips) 

  private function possible_withdraw_amount(tips: list(tip)) : int =
    sum((single_tip) => (single_tip.amount), tips)

  private function filter_unpaid_tips(tips: list(tip)) : list(tip) =
    filter((single_tip) => (is_repaid(single_tip)), tips)

  private function is_repaid(tip: tip) : bool =
    tip.repaid

  private function current_ownership_tips(tips: list(tip), time: timeframe) : list(tip) =
    filter((single_tip) => (diff(single_tip, time)), tips)

  private function diff(tip : tip, timeframe: timeframe) : bool = tip.date_received >= timeframe.date_from && tip.date_received =< timeframe.date_to

  private function get_tips_for_payment_list(domain: string) : list(tip) =
    // check if the call.caller is the domain owner
    // return all the tips for certain domain
    []

  private function set_tips_repaid(tips: list(tip)) : bool =
    // iterate over all the tips in list and set the repaid property to true
    // this is to prevent reentrancy
    true

  private stateful function challenge_generate(domain: string) : hash =
    let challenge = String.sha3(domain)
    put(state{websites[domain].challenge = challenge})
    challenge

  private function challenge_check(domain: string) : bool =
    // Call oracle and verify challenge
    true

  private function is_domain_owner(domain: string) =
    require(state.websites[domain].owner[Call.caller].date_to != 0
      && state.websites[domain].owner[Call.caller].date_from =< Chain.timestamp
      && state.websites[domain].owner[Call.caller].date_to >= Chain.timestamp
      , "You are not the owner of this domain")

  private function is_enough_balance(domain: string) =
    require(state.websites[domain].balance > 0, "Not enough balance")

  public function all_domain_expire_dates(domain) : list(int) =
    let domain_expires_list = Map.to_list(state.websites[domain].owner)
    map(tuple_second, domain_expires_list)

  private function is_domain_expired(domain: string) : bool =
    is_domain_expired'(all_domain_expire_dates(domain))

  private function is_domain_expired'(domain_expires_list: list(int)) : bool =
    switch(domain_expires_list)
      [] => true
      e :: l' =>
        if(e =< Chain.timestamp)
          false
        else
          is_domain_expired'(l')

  private stateful function is_website_present(domain: string) =
    if(!Map.member(domain, state.websites))
      let website : website = {
        domain = domain,
        challenge = challenge_generate(domain),
        verified = false,
        date_expire = 0,
        owner = {},
        balance = 0,
        tips = [] }
      put(state{websites[domain] = website})

  private function tuple_second(tuple) =
    switch(tuple)
      (_, e) => e.date_to

  // general helper functions //

  private function sum(f : 'a => int, l : list('a)) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  private function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  private function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))

  private function insert_by(f: (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =
    switch(l)
      [] => [x]
      (e :: l') =>
        if(f(x, e))
          e :: insert_by(f, x, l')
        else
          x :: l

  private function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  private function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

  private function is_greater_zero(x : int) : bool = x > 0