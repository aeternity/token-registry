contract WaelletTip =
  record state = {
    websites: map(string, website) }

  record website = {
    domain: string,
    challenge: hash,
    verified: bool,
    date_expire: int,
    owner: map(address, timeframe),
    balance: int,
    tips: list(tip) }

  record tip = {
    repaid: bool,
    sender: address,
    date_received: int,
    amount: int }

  record timeframe = {
    date_from: int,
    date_to: int }

  datatype event = 
      LogTipReceived(indexed address, indexed int, string) 
    | LogWebsiteVerified(indexed address, indexed int, string)

  public stateful function init() = 
    { websites = {} }

  public stateful function tip(domain: string) =
    is_website_present(domain)
    let tip : tip = {
      repaid = false,
      sender = Call.caller,
      date_received = Chain.timestamp,
      amount = Call.value }

    put(state{websites[domain].tips = tip :: state.websites[domain].tips})
    put(state{websites[domain].balance = Call.value + state.websites[domain].balance})
    Chain.event(LogTipReceived(Call.caller, Call.value, domain))

  public function balance(domain:string) : int =
    state.websites[domain].balance

  public stateful function claim(domain: string) : hash =
    is_domain_expired(domain)
    challenge_generate(domain)

  public stateful function withdraw(domain: string) =
    is_domain_owner(domain)
    is_enough_balance(domain)
    let tips_for_payment_list = get_tips_for_payment_list(domain: string)
    let withdraw_amount = get_withdraw_amount(tips_for_payment_list)
    require(withdraw_amount > 0, "You dont have pending balance for withdrawal")
    put(state{websites[domain].balance = state.websites[domain].balance - withdraw_amount})
    require(set_tips_repaid(tips_for_payment_list), "Something went wrong with the tips")
    Chain.spend(Call.caller, withdraw_amount)

  private function get_withdraw_amount(tips_for_payment: list(tip)) : int =
    // filter the tips for the current timeframe ownership
    // filter the repaid tips
    // return the possible withdraw amount
    0 

  private function get_tips_for_payment_list(domain: string) : list(tip) =
    // check if the call.caller is the domain owner
    // return all the tips for certain domain
    []

  private function set_tips_repaid(tips: list(tip)) : bool =
    // iterate over all the tips in list and set the repaid property to true
    // this is to prevent reentrancy
    true

  private stateful function challenge_generate(domain: string) : hash =
    let challenge = String.sha3(domain)
    put(state{websites[domain].challenge = challenge})
    challenge

  private function challenge_check(domain: string) : bool =
    // Call oracle and verify challenge
    true

  private function is_domain_owner(domain: string) =
    require(state.websites[domain].owner[Call.caller].date_to != 0
      && state.websites[domain].owner[Call.caller].date_from =< Chain.timestamp
      && state.websites[domain].owner[Call.caller].date_to >= Chain.timestamp
      , "You are not the owner of this domain")

  private function is_enough_balance(domain: string) =
    require(state.websites[domain].balance > 0, "Not enough balance")

  public function all_domain_expire_dates(domain) : list(int) =
    let domain_expires_list = Map.to_list(state.websites[domain].owner)
    map(tuple_second, domain_expires_list)

  private function is_domain_expired(domain: string) : bool =
    is_domain_expired'(all_domain_expire_dates(domain))

  private function is_domain_expired'(domain_expires_list: list(int)) : bool =
    switch(domain_expires_list)
      [] => true
      e :: l' =>
        if(e =< Chain.timestamp)
          false
        else
          is_domain_expired'(l')

  private stateful function is_website_present(domain: string) =
    if(!Map.member(domain, state.websites))
      let website : website = {
        domain = domain,
        challenge = challenge_generate(domain),
        verified = false,
        date_expire = 0,
        owner = {},
        balance = 0,
        tips = [] }
      put(state{websites[domain] = website})

  private function tuple_second(tuple) =
    switch(tuple)
      (_, e) => e.date_to

  // general helper functions //

  private function sum(f : 'a => int, l : list('a)) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  private function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  private function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))

  private function insert_by(f: (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =
    switch(l)
      [] => [x]
      (e :: l') =>
        if(f(x, e))
          e :: insert_by(f, x, l')
        else
          x :: l

  function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  private function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

  private function is_greater_zero(x : int) : bool = x > 0

  private function require(b : bool, err : string) =
    if(!b) abort(err)