contract WaelletTip =

  record state = { websites: map(string, website) }

  record website = { domain: string
                   , challenge: string
                   , verified: bool
                   , date_expire: int
                   , owner: map(address, timeframe)
                   , balance: int
                   , tips: map(int, tip)
                   , tip_seq_id: int }

  record tip = { seq_id: int
               , repaid: bool
               , sender: address
               , date_received: int
               , amount: int
               , note: option(string) }

  record timeframe = { date_from: int
                     , date_to: int }

  datatype event = 
      LogTipReceived(indexed address, indexed int, string) 
    | LogWebsiteVerified(indexed address, indexed int, string)
    | LogTipsWithdrawn(indexed address, indexed int)

  entrypoint init() = { websites = {} }

  stateful entrypoint tip(domain: string, note: option(string)) =
    is_website_present(domain)
    let tip : tip = { seq_id = state.websites[domain].tip_seq_id
                    , repaid = false
                    , sender = Call.caller
                    , date_received = Chain.timestamp
                    , amount = Call.value
                    , note = note }

    put(state{ websites[domain].tips[state.websites[domain].tip_seq_id] = tip })
    put(state{ websites[domain].balance = Call.value + state.websites[domain].balance
             , websites[domain].tip_seq_id = state.websites[domain].tip_seq_id + 1 })
    Chain.event(LogTipReceived(Call.caller, Call.value, domain))

  entrypoint balance(domain:string) : int =
    state.websites[domain].balance

  stateful entrypoint claim(domain: string) : string =
    is_domain_expired(domain)
    challenge_generate(domain)

  stateful entrypoint withdraw(domain: string) =
    is_domain_owner(domain)
    is_enough_balance(domain)
    let tips_for_payment_list = get_tips_for_payment_list(domain: string)
    let withdraw_amount = get_withdraw_amount(tips_for_payment_list, domain: string)
    require(withdraw_amount > 0, "INSUFFICIENT_BALANCE")
    put(state{websites[domain].balance = state.websites[domain].balance - withdraw_amount})
    require(set_tips_repaid(tips_for_payment_list, domain), "ERROR_TIPS")
    Chain.spend(Call.caller, withdraw_amount)
    Chain.event(LogTipsWithdrawn(Call.caller, withdraw_amount))

  // PRIVATE FUNCTIONS AND MODIFIERS

  function get_withdraw_amount(tips_for_payment: list(tip), domain: string) : int =
    // filter the tips for the current timeframe ownership
    let tips = current_ownership_tips(tips_for_payment, state.websites[domain].owner[Call.caller] : timeframe)
    // filter the repaid tips
    let unpaid_tips = filter_unpaid_tips(tips)
    // return the possible withdraw amount
    possible_withdraw_amount(unpaid_tips) 

  function possible_withdraw_amount(tips: list(tip)) : int =
    sum((single_tip) => (single_tip.amount), tips)

  function filter_unpaid_tips(tips: map(int, tip)) : list(tip) =
    let tips_list = Map.to_list(tips)
    filter((single_tip) => (is_repaid(single_tip)), tips_list)

  function is_repaid(tip: tip) : bool =
    tip.repaid

  function current_ownership_tips(tips: list(tip), time: timeframe) : list(tip) =
    filter((single_tip) => (diff(single_tip, time)), tips)

  function diff(tip : tip, timeframe: timeframe) : bool = tip.date_received >= timeframe.date_from && tip.date_received =< timeframe.date_to

  function get_tips_for_payment_list(domain: string) : list(tip) =
    // check if the call.caller is the domain owner
    require(is_domain_owner(domain), "UNAUTHORIZED_ACCESS")
    // return all the tips for certain domain
    filter_unpaid_tips(state.websites[domain].tips)

  stateful function set_tips_repaid(tips: list(tip), domain: string) : bool =
    // iterate over all the tips in list and set the repaid property to true
    // map(set_tips_repaid'(tip, domain), tips)
    // this is to prevent reentrancy
    true

  stateful function set_tips_repaid'(tip: tip, domain: string) : bool =
    // put(state{websites[domain].tips})
    true

  stateful function challenge_generate(domain: string) : string =
    let challenge = Bytes.to_str(Crypto.sha3(domain))
    put(state{websites[domain].challenge = challenge})
    challenge

  function challenge_check(domain: string) : bool =
    // Call oracle and verify challenge
    true

  function is_domain_owner(domain: string) =
    require(state.websites[domain].owner[Call.caller].date_to != 0
      && state.websites[domain].owner[Call.caller].date_from =< Chain.timestamp
      && state.websites[domain].owner[Call.caller].date_to >= Chain.timestamp
      , "NOT_DOMAIN_OWNER")

  function is_enough_balance(domain: string) =
    require(state.websites[domain].balance > 0, "INSUFFICIENT_BALANCE")

  entrypoint all_domain_expire_dates(domain) : list(int) =
    let domain_expires_list = Map.to_list(state.websites[domain].owner)
    map(tuple_second, domain_expires_list)

  function is_domain_expired(domain: string) : bool =
    is_domain_expired'(all_domain_expire_dates(domain))

  function is_domain_expired'(domain_expires_list: list(int)) : bool =
    switch(domain_expires_list)
      [] => true
      e :: l' =>
        if(e =< Chain.timestamp)
          false
        else
          is_domain_expired'(l')

  stateful function is_website_present(domain: string) =
    if(!Map.member(domain, state.websites))
      let website : website = { domain = domain
                              , challenge = challenge_generate(domain)
                              , verified = false
                              , date_expire = 0
                              , owner = {}
                              , balance = 0
                              , tips = {}
                              , tip_seq_id = 0 }
      put(state{websites[domain] = website})
  
  // general helper functions //

  function tuple_second(tuple) =
    switch(tuple)
      (_, e) => e.date_to

  function sum(f : 'a => int, l : list('a)) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))

  function insert_by(f: (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =
    switch(l)
      [] => [x]
      (e :: l') =>
        if(f(x, e))
          e :: insert_by(f, x, l')
        else
          x :: l

  function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

  function is_greater_zero(x : int) : bool = x > 0